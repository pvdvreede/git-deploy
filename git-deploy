#!/usr/bin/env python3

import os
import base64
import subprocess
import shutil


def run(repo, path=".", passphrase=None, force=False, branch="main"):
    has_cloned=False
    is_updated=False
    path = os.path.abspath(path)

    if passphrase and not has_git_crypt():
        raise Exception("You want to use git_crypt but its not installed.")

    if not has_repo(path):
        has_cloned=True
        clone_repo(repo, path)

    if not has_cloned:
        is_updated = pull_repo(repo, path, branch=branch)

    if passphrase and repo_locked(path):
        decrypt_repo(path, passphrase)

    if not has_cloned and not is_updated and not force:
        print("Repo has not changed, so nothing to do.")
        return

    compose_files = check_compose_files(path)

    if len(compose_files) == 0:
        print("No docker-compose files found in the root of the repo.")
        return

    run_compose_up(path, compose_files)


def sh(cmd):
    print("running command: {}".format(cmd))
    resp = os.popen(cmd).read()
    print("Got response: {}".format(resp))
    return resp


def clone_repo(repo, path):
    sh("git clone {} {}".format(repo, path))


def repo_locked(path):
    return True


def has_git_crypt():
    if shutil.which("git-crypt"):
        return True

    return False


def has_repo(repo_path):
    return os.path.isdir(repo_path)


def get_repo_sha(path):
    return sh("git -C {} rev-parse HEAD".format(path)).strip()


def pull_repo(repo, path, branch="main", remote="origin"):
    old_sha = get_repo_sha(path)
    sh("git -C {} pull {} {}".format(path, remote, branch))
    new_sha = get_repo_sha(path)
    return new_sha != old_sha


def decrypt_repo(path, passphrase):
    print("Unlocking repo...")
    subprocess.call('echo "{}" | base64 --decode | git -C {} crypt unlock -'.format(passphrase, path), shell=True)


def check_compose_files(path):
    files = []
    if os.path.isfile(os.path.join(path, 'docker-compose.yml')):
        files.append('docker-compose.yml')

    if os.path.isfile(os.path.join(path, 'docker-compose.deploy.yml')):
        files.append('docker-compose.deploy.yml')

    return files


def run_compose_up(path, compose_files):
    os.chdir(path)
    file_string = ' '.join(["-f {}".format(x) for x in compose_files])
    up_cmd = "docker-compose {} up --force-recreate -d".format(file_string)
    sh("docker-compose stop")
    sh("docker-compose kill")
    sh("docker-compose rm -f")
    sh(up_cmd)



if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='git-deploy to sync and deploy docker-compose apps.')
    parser.add_argument('repository', metavar='R', type=str, help='remote repository to sync')
    parser.add_argument('--path', type=str, help="The local path to clone the repo to, default to the current dir.", default=".")
    parser.add_argument('--force', action='store_true', help="Ignore if the repo is updated or not and deploy.")
    parser.add_argument('--passphrase', type=str, help="Passphrase used to decrypt transcrypt files.", default=None)
    parser.add_argument('--branch', type=str, help="Git repo branch to use, defaults to main.", default="main")

    args = parser.parse_args()

    run(args.repository, path=args.path, force=args.force, branch=args.branch, passphrase=args.passphrase)
